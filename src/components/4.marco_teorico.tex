% \mysection{4}{MARCO TEÓRICO}
\section{MARCO TEÓRICO}

\subsection{Antecedentes}

\subsection{Arquitectura de Microservicios}

De acuerdo con \cite{dmitry2014micro}, un microservicio es un servicio ligero e independiente que
realiza funciones únicas y colabora con otros servicios similares utilizando una interfaz bien definida.
Una arquitectura basada en microservicios es un método para desarrollar una aplicación como un conjunto
de servicios pequeños e independientes. Cada uno de los servicios está siendo ejecutado bajo un
proceso independiente propio. Dichos servicios pueden comunicarse mediante mecanismos ligeros (usualmente
bajo HTTP). Servicios como estos pueden ser desplegados completamente independientes los unos de los otros.
Los servicios pueden estar escritos en diferentes lenguajes de programación, diferentes paradigmas,
usar sus propios modelos de datos, etcétera.

Por su parte \cite{alshuqayran2016systematic} definen la arquitectura de microservicios como el estilo de arquitectura
que pone énfasis en dividir el sistema en servicios pequeños y ligeros que están construidos para
llevar a cabo una función de negocio de manera muy cohesiva.

Según el principio de responsabilidad única definido por \cite{martin2013clean} nos indica "juntar las
cosas que cambian por la misma razón, y separar las cosas que cambian por razones diferentes".
Los microservicios usan el mismo enfoque a los servicios independientes, trazando las fronteras
de cada servicio para coincidir con las fronteras del dominio del negocio para que así
se tengan unidades independientes y desacopladas.

Mientras que \cite{newman2019monolith} indica que para definir una arquitectura de microservicios primero tenemos que
definir a los microservicios. Los microservicios son un conjunto de servicios independientemente
desplegables modelados alrededor de un dominio de negocio. Se comunican entre ellos mediante redes
y como una elección de arquitectura ofrecen varias opciones para resolver los problemas que un
equipo u organización pueden enfrentar. Por lo anterior indicado, se concluye que una arquitectura
de microservicios es una arquitectura basada en múltiples microservicios trabajando en colaboración.

En resumen una arquitectura de microservicios está constituida por múltiples unidades que pueden ser
desplegadas independientemente las unas de las otras. Este conjunto de servicios han sido desarrollados
para solucionar problemas de un dominio de negocio.


\subsection{Servicio Web}

Para \cite{bruijn2006web} los servicios web son piezas de funcionalidad que son accesibles mediante la web.
La comunicación con estos se da mediante protocolos abiertos que se definen mediante estándares internacionales.
Diferentes clientes y aplicaciones desarrolladas en lenguajes de programación diferentes y ejecutándose
en sistemas operativos diferentes pueden comunicarse con los servicios web que implementan
los protocolos de comunicación.

De acuerdo con \cite{percival2020architecture} los servicios web deberían tener otra denominación para evitar
confusiones con términos como ``capa de servicio''.
Ellos definen a un servicio como una pieza de lógica que pertenece al dominio del modelo pero que no se encuentra
naturalmente dentro de una entidad con estado o un objeto valor.


\subsection{Protocolo de Transferencia de Hipertexto (HTTP)}

Según \cite{goralski2017illustrated} el protocolo de transferencia de hipertexto (HTTP) es un protocolo de nivel de aplicación para sistemas de información
distribuidos, colaborativos y de hiper-media.
El protocolo es genérico, sin estado ({\it stateless}) que puede ser usado para muchas tareas más allá el uso para hipertexto.
Su extensibilidad se da por sus métodos de solicitud ({\it request methods}), códigos de error y cabeceras.

De acuerdo con \cite{gourley2002http} el HTTP es la lengua franca del Internet moderno.
HTTP es utilizado para enviar y recibir todo tipo de información de manera rápida, conveniente y confiable
desde servidores web de todo el mundo hacia los navegadores en las terminales de las personas.
El protocolo que usa HTTP para transmitir datos garantiza que la data no va a dañarse o perderse en
tránsito.


\subsection{Microservicios}

Para su más fácil definición, hay que describir sus principales características.


\subsubsection{Pequeños y Enfocados en Hacer una Cosa y Hacerla Bien}

Una de las características principales de los microservicios es que son {\it pequeños}, este es un
punto de contención, ya que la definición de {\it pequeño} es problemática.
Según \cite{newman2021building}, no podemos asignar la etiqueta de {\it pequeño} basándonos en líneas
de código ya que diferentes lenguajes de programación son más o menos expresivos.
Además de que los dominios de problema pueden ser tener una complejidad elevada lo cual hace imposible
expresar su solución en pocas líneas de código.

Debido a lo anterior mencionado, Newman indica que son los dueños del código (los desarrolladores)
los encargados de definir {pequeño} según el contexto.
Cabe mencionar que los programadores entienden intuitivamente cuando el sistema en el que están trabajando
es {\it muy grande}.

Por su lado \cite{kleppmann2015kafka} menciona el cómo la filosofía UNIX influyó al diseño de la arquitectura
de microservicios:
\vspace{-1em}
\begin{enumerate}[a.]
  \item Hacer que cada programa haga una cosa y que la haga bien.
  \item Hacer que los programas puedan trabajar juntos
  \item Hacer que los programas puedan mantener inputs de textos, porque es una interfaz universal
\end{enumerate}
\vspace{-1em}

Con respecto al tercer punto, en lugar de hacer las comunicaciones mediante {\it standard input},
los microservicios se comunican mediante HTTP.


\subsubsection{Autónomos}

De acuerdo con \cite{newman2019monolith}, los microservicios son entidades separadas.
Cada microservicio puede ser desplegado como un servicio aislado o puede ser su propio proceso
de un sistema operativo.
Estos servicios tienen que tener la capacidad de ser cambiados independientemente de sus pares
y ser desplegados de manera tal que los clientes que consumen el servicio no necesiten de cambiar.

Mientras que \cite{nadareishvili2016microservice} indican que la autonomía de servicios es posible
gracias al diseño de interoperabilidad mediante comunicación vía mensajería.
Debido a lo anteriormente mencionado, los microservicios son necesariamente una forma de una
arquitectura basada en servicios (SOA por sus siglas en inglés); además de que, debido a la
complejidad en el despliegue de microservicios es casi una necesidad el implementar prácticas de
DevOps (desarrollo y operaciones) para la automatización del despliegue.


\subsection{Dominio de Negocio}

De acuerdo con \cite{bosselmann2014domain} para definir un dominio de negocio de manera formal,
no existe una ontología formal adecuada para los desarrolladores de software.
Debido a esto solo se puede definir el dominio de negocio como lo siguiente: una descripción
del valor que una compañía ofrece a uno o varios segmentos de clientes y la arquitectura de
la firma y su red de socios para crear, publicitar y entregar su valor y capital relacional,
con el fin de generar flujos de ingresos rentables y sostenibles.

Por su parte \cite{heidari2021ontology} definen al dominio de negocio como las esferas específicas
para las soluciones orientadas a negocios.
El concepto se refiere a los aspectos en el mundo real de la solución ofrecida por el negocio o empresa.
Para los desarrolladores, el dominio de negocio indica los requerimientos y los criterios de aceptación
para el sistema a desarrollar.
Estos criterios pueden indicar un nivel alto de segregación para diferentes áreas.

Según \cite{khononov2021learning} un dominio de negocio define el principal área de actividad de
la empresa. En general es el servicio que la empresa provee a sus clientes.
Una empresa puede operar en múltiples dominios de negocio.


\subsection{Diseño Guiado por el Dominio}

El término ``diseño guiado por el dominio'' fue acuñado por \cite{evans2004domain}, en su trabajo
indica los tres componentes del DDD:

\vspace{-1em}
\begin{enumerate}[a.]
  \item \textbf{El modelo y el núcleo del diseño se dan forma mutuamente.}
    Es el enlace entre el modelo y la implementación que hace que el modelo sea relevante y asegura que el
    análisis que se le hizo aplica al producto final.
  \item \textbf{El modelo es la columna vertebral del lenguaje utilizado por todos los miembros del equipo.}
    Debido al vínculo entre modelo e implementación, los desarrolladores pueden hablar acerca del
    programa en este lenguaje, esto con el fin de poder hablar con los expertos del dominio sin
    necesidad de traducción.
  \item \textbf{El modelo es conocimiento destilado.}
    El modelo es la forma de estructurar conocimiento del dominio acordado por el equipo.
\end{enumerate}
\vspace{-1em}

Prosiguiendo con su definición, Evans indica que la razón principal de ser del software es el
resolver problemas relacionados con un dominio en específico para sus usuarios.
Con respecto a las demás características, afirma que son subordinadas a la razón principal.

Según \cite{percival2020architecture} el Diseño guiado por el dominio (DDD por sus siglas en inglés)
hace que los practicantes centren sus esfuerzos construyendo un buen modelo del dominio del negocio.
Básicamente DDD indica que lo más importante del software es que provee un modelo útil de un problema,
si ese modelo es correcto, entonces el software entregará valor.
En el caso contrario, la aplicación se vuelve un obstáculo.


\subsubsection{Análisis del Dominio}


\subsubsection{Definir contextos delimitados}


\subsubsection{Definir entidades, agregados y servicios}


\subsubsection{Identificar los microservicios}

\subsection{Dominios}

\subsubsection{Sub-dominios}


\subsection{Ley de Conway y La Importancia de la Comunicación}

Existen patrones en las arquitecturas utilizadas por cada organización, estas observaciones
las hizo \cite{conway1968committees}: ``Cualquier organización que diseñe un sistema producirá
un diseño que copia la estructura de comunicación de dicha organización''

% \begin{quote}
% ``Cualquier organización que diseñe un sistema producirá un diseño que copia la estructura de
% comunicación de dicha organización''
% \end{quote}

De acuerdo a estas observaciones \cite{newman2019monolith} asevera que la arquitectura de tres capas
(MVC) surge de la forma en la cual organizaciones de TI agrupaban a las personas: se creaban grupos
separados de administradores de bases de datos, desarrolladores de infraestructura y desarrolladores
de interfaces gráficas. Entonces concluye que si agrupamos a las personas con respecto a sus competencias
principales, estas personas organizarán el software de manera similar.

Actualmente la forma más común de agrupar personas en organizaciones de TI es en equipos multidisciplinarios
armando equipos ágiles que tienen la responsabilidad de lanzar software de calidad lo más rápido posible.
Siguiendo esta evolución natural de los equipos de desarrollo, Newman concluye que los microservicios,
además de ser una arquitectura de software, reflejan la forma de comunicación de la organización
que los implementa.

De igual forma, \cite{nadareishvili2016microservice} indican que, en términos sencillos, la
{\it la comunicación dicta el resultado}, por lo cual hacen hincapié en que la calidad de un sistema
depende casi exclusivamente de los canales de comunicación que establece la organización que lo implementa.
Por lo tanto, las organizaciones que quieren aplicar la arquitectura de microservicios, necesitan
organizar los equipos que trabajarán en el producto de tal manera que su comunicación sea similar a 
la arquitectura.


\subsection{Acoplamiento}

Según \cite{newman2019monolith} el acoplamiento es la característica de un programa que mide el cómo
cambiar código en un lugar requiere cambiar el programa en otro lugar.
Los dos tipos de acoplamiento más comunes son: el acoplamiento de implementación y el acoplamiento temporal.
El acoplamiento de implementación suele darse cuando componentes comparten un flujo de datos y es el más
sencillo de solucionar.
El acoplamiento temporal tiene que ver con el momento de ejecución y es uno de los principales
desafíos de hacer llamadas síncronas en un entorno distribuido.

De acuerdo con \cite{percival2020architecture} el acoplamiento es cuando los desarrolladores no
pueden cambiar el componente A por miedo a romper el componente B. También indican que el
acoplamiento a nivel local es algo bueno porque es un signo que el módulo ha sido agrupado correctamente.
De igual manera advierten de los problemas que trae el tener acoplamiento a nivel global que trae
consigo el incremento de los riesgos y costos de cambiar el código base.


\subsection{Cohesión}

De acuerdo con \cite{newman2019monolith} la cohesión describe el cómo se agrupa el código relacionado,
básicamente: {\it el código que cambia en conjunto, se agrupa}.
El organizar el código base utilizando la cohesión hace que las modificaciones que inevitablemente
va a necesitar, sea una operación sencilla.
Cuando la cohesión se respeta el equipo de desarrollo puede moverse rápidamente debido a que no tiene
que buscar lógica en múltiples lugares, sino que solo en un único módulo.

Mientras que \cite{percival2020architecture} indica que la cohesión es un indicador de que los componentes
se apoyan entre sí, cada cual encajando como los engranajes de un reloj.
Además de esto, alertan sobre el anti-patrón Bola de Barro: mientras la aplicación crece, si se es incapaz de
prevenir el acoplamiento entre elementos que no tienen cohesión, el acoplamiento escalará de manera superlineal
hasta que ya no se pueda modificar efectivamente el sistema.


\subsection{Despliegue}


\subsubsection{Despliegue Acoplado}

\cite{newman2019monolith} menciona que el despliegue acoplado se encuentra en sistemas en los que el
despliegue de un servicio, necesita del despliegue de otro servicio.
Entonces, se entiende que el hacer cambios, por más minúsculos que sean, involucran a todos los módulos
de la aplicación.

Según \cite{nadareishvili2016microservice} el despliegue acoplado se da cuando existe la necesidad
de compartir data entre módulos.
También indica que una metodología de cascada suele llevar a que la implementación del sistema
quede fuertemente acoplado.


\subsubsection{Despliegue Independiente}

De acuerdo con \cite{newman2019monolith} el despliegue independiente es la idea de que podemos
hacer un cambio a un microservicio y desplegarlo a un ambiente de producción sin tener que utilizar
ningún otro servicio.
En este tipo de despliegue, un cambio puede ser desplegado sin necesidad de desplegar todo el sistema,
sino solo el módulo o servicio que sufrió el cambio.

Según \cite{nadareishvili2016microservice} el despliegue independiente es un principio fundamental
en el estilo arquitectónico de microservicios.
En pocas palabras, el despliegue independiente es la posibilidad de poder desplegar un 
servicio de manera tal que no dependa de ningún otro servicio.
Esto permite que sea posible el llevar a cabo escalabilidad selectiva o bajo demanda.


\subsection{Escalabilidad}

De acuerdo con \cite{rodger2017tao} la escalabilidad es una necesidad para sistemas de alto rendimiento.
En la etapa de su diseño es necesario utilizar métodos de escalabilidad del tipo "mantenimiento casero"
(servidores de proxy).
De la misma manera indica que en un acercamiento tradicional ocurre que mientras más se mejore la 
escalabilidad, la latencia va a empeorar a menos que se utilicen máquinas más poderosas y costosas,
por lo cual es necesario hacer un compromiso para tener estos dos atributos equilibrados.

Por su lado \cite{lehrig2015scalability}, define la escalabilidad como la habilidad de una capa
de la nube de incrementar su capacidad expandiendo la cantidad de servicios de capas más bajas
que consume.
En términos prácticos significa que una aplicación mantiene sus metas de rendimiento incluso cuando
la carga de trabajo incrementa (hasta cierto límite de carga).


\subsection{Fiabilidad}

De acuerdo con \cite{humble2018accelerate}, tradicionalmente la fiabilidad define como el tiempo
entre fallos del sistema.
Sin embargo, con los sistemas y servicios de software modernos (muy cambiantes y de alta complejidad),
los fallos son inevitables por lo cual una mejor definición sería: ¿qué tan rápido un servicio puede
ser restaurado?
La pregunta planteada es una mejor métrica de calidad del software moderno, además de estar más ajustada
a la realidad del desarrollo de software actual.

Según \cite{rodger2017tao}, la fiabilidad es la cantidad de peticiones exitosas divididos
por la cantidad total de peticiones que los clientes hacen a un servidor.
Es junto con este concepto que se habla de la tasa de fracaso.
Por otro lado, Rodger menciona que en sistemas distribuidos la tasa de fracaso depende del
componente menos confiable y de la fiabilidad de las redes.


\subsection{Patrones de Diseño}

Según \cite{cosmin2016patrones} los patrones de diseño son soluciones maduras y probadas que
se encuentran al momento de desarrollar software.
La forma más extendida de categorizarlos es según el propósito que cumplen: de creación, de comportamiento
y estructurales.

De acuerdo con \cite{lo2022architectural} un patrón de diseño es una solución reutilizable que puede
ser aplicada a problemas comunes de la etapa del desarrollo de software.
Dentro de estos patrones de diseño se encuentran los patrones de arquitectura que ofrecen soluciones
arquitectónicas a problemas de alto nivel encontrados en la arquitectura general de la aplicación.

\subsection{Patrón API Gateway}

\cite{trebichavsky2021api} indica que el fin de este patrón es centralizar todas las solicitudes
de los posibles múltiples clientes a los servicios.
Un API Gateway es el encargado de recibir todas las solicitudes, llamar a los servicios necesarios
y devolver la información solicitada por el cliente.
Puede ser nada más que un proxy uno a uno o puede llamar a varios servicios para obtener los datos 
requeridos.

Por su lado \cite{tomic2022towards} menciona que este patrón nace de afrontar el problema común
de implementar microservicios: la cantidad de APIs expuestas aumenta considerablemente la carga de trabajo
tanto para los desarrolladores que mantienen las integraciones de las APIs como de los usuarios que
tienen la necesidad de estar conscientes de demasiados endpoints de servicios.
Debido a lo anterior mencionado, una arquitectura de microservicios debe incluir un módulo de 
API gateway para aliviar estos problemas y proveer un único punto de conexión.
  

\subsection{Servidor Proxy}

De acuerdo con \cite{wenceslao2022network} un servidor proxy tiene como característica primordial el ser
un re-enviador de solicitudes.
Es decir cuando llega una solicitud al servidor proxy, este debe tomar la información de dirección
de la solicitud, reenviarla hacia el servicio correcto, esperar la respuesta y finalmente devolver
dicha respuesta al cliente original.
Además de la característica primordial, un servidor proxy puede mantener caché y puede filtrar solicitudes.

Según \cite{agyekum2021proxy} los servidores proxy pueden ser aprovechados para hacer delegar
diferentes funcionalidades tradicionales del cliente.
Esto para tener un mayor control sobre la seguridad y fiabilidad de la aplicación.
Además de los beneficios obtenidos de utilizar un servidor proxy para manejar la redirección
de tráfico, puede dar beneficios de seguridad al ocultar recursos importantes del internet global.

\subsection{Integración y Distribución Continuas}

\cite{humble2018accelerate} indican que tal como la Programación Extrema (XP) prescribe técnicas prácticas,
la evolución lógica de los marcos de trabajo ágiles prescriben más técnicas como habilitadores de
distribución de software más frecuente, de mayor calidad y de menor riesgo.
También hacen insistencia en que las técnicas practicas juegan un rol vital en la entrega de software de calidad.
La integración continua es una necesidad del software moderno, debido a la forma de trabajo de equipos
ágiles que trabajan en diferentes partes del software, a veces sobre el mismo módulo, estas prácticas
hacen que gran parte del tiempo del proceso de desarrollo de software está en la integración
de los diferentes cambios que diferentes equipos e individuos realizan al software.
Debido a lo anterior mencionado, la Integración Continua se vuelve una necesidad.

Para una mejor comprensión de qué es Distribución Continua se describen los siguientes cinco principios clave:

\vspace{-1em}
\begin{enumerate}[a.]
  \item \textbf{Construir calidad en el sistema.}
    En una cultura de Distribución Continua, se invierte en dar soporte al monitoreo de problemas
    que pueden surgir del sistema para que puedan ser corregidas rápidamente cuando son baratas de
    detectar y resolver, esto mediante el uso herramientas y personas.
  \item \textbf{Trabajo en lotes pequeños}
    Al entregar lotes de trabajo que entregan resultados de negocio tangibles rápidamente,
    las organizaciones obtienen valiosa retroalimentación y pueden ajustar el rumbo sobre la
    marcha.
  \item \textbf{Computadores hacen tareas repetitivas; las personas resuelven problemas}
    Si bien la inversión inicial en automatizar tareas repetitivas puede desalentar a las organizaciones,
    el mayor beneficio que se obtiene es el liberar a personas para tomar tareas más valiosas resolviendo
    problemas del negocio.
  \item \textbf{Perseguir la mejora continua implacablemente}
    Se identificó que la característica más importante de equipos de alto rendimiento es que nunca
    están satisfechos, siempre quieren mejorar sus procesos.
    Las personas que tienen alto rendimiento hacen la mejora parte del día a día.
  \item \textbf{Todos son responsables}
    El objetivo clave del nivel de administración es hacer que la organización pueda trabajar en conjunto
    con transparencia para poder definir metas mensurables, factibles y oportunas para el producto.
\end{enumerate}
\vspace{-1em}

De acuerdo con \cite{forsgren2019}, la integración y distribución continua es una práctica clave
para hacer que el proceso de desarrollo de software sea confiable y eficiente.
Si bien existen desafíos con implementar un proceso automático completo de integración y distribución
continua, las ventajas que ofrece esta practica son suficientes para justificar la implementación.
El tener el proceso de entrega automatizado hace que el proceso iterativo de desarrollo de software
tenga más y mejor retroalimentación.


\subsection{Herramientas Para Facilitar la Adopción de Microservicios}

\subsubsection{Lenguajes de Scripting para la Automatización de Procesos}

Los procesos para poder desplegar un sistema distribuido de microservicios son demasiados como para que 
un humano pueda repetir el proceso de manera confiable y veloz cada que se necesite desplegar un servicio.
Este proceso suele estar plagado de sobreescribir variables de entorno, copiar repositorios remotos
a un servidor, modificar los permisos de red, comprobar la integración de los servicios y un largo etcétera
de tareas.
Debido a esto, esta parte del proceso se automatiza siguiendo el principio de ``dejar el trabajo repetitivo
a las máquinas, dejar la solución de problemas a los humanos''.

Para esta automatización pueden usar diferentes lenguajes de programación para crear herramientas internas
especializadas para la gestión interna del sistema.
La lista de lenguajes más usados para este fin es:

\vspace{-1em}
\begin{enumerate}[a.]
  \item \textbf{Bash script.}
    El usar este lenguaje trae muchas ventajas, entre las principales están: estar presente en todos
    los sistemas basados en UNIX e interoperabilidad con los GNU-core-utils.
  \item \textbf{Python.}
    Lenguaje interpretado sencillo de escribir y leer.
    Debido a esto un programador experimentado puede ser productivo inmediatamente al cambiar a este lenguaje.
  \item \textbf{Go.}
    Lenguaje compilado simple y de buen rendimiento.
    El tiempo que toma un programador experimentado en ser ``productivo'' con Go es muy corto comparado con
    lenguajes de rendimiento similar.
    Este hecho sumado a su rendimiento y la librería principal hacen de Go un lenguaje muy atractivo
    para los Ingenieros de Confiabilidad de Sitio (SRE).
\end{enumerate}
\vspace{-1em}


\subsubsection{Virtualización en Contenedores}
De acuerdo con \cite{celesti2016exploring} a diferencia de tecnologías tradicionales de virtualización,
los contenedores no requieren de un sistema operativo además de poder correr dentro de una Máquina Virtual.
Los contenedores proveen de virtualización a nivel de Sistema Operativo aprovechando prestaciones del kernel
para aislar procesos y definir límites de uso de sistema para recursos como CPU, memoria, dispositivos de
entrada/salida.

Las tecnologías de Contenedores más comunes son:
\vspace{-1em}
\begin{enumerate}[a.]
  \item \textbf{Docker.}
    Según \cite{celesti2016exploring} Docker ofrece una agilidad en desarrollo y ejecución de aplicaciones
    en entornos de nube.
    Ofrece la solución completa para una plataforma de contenedores.
  \item \textbf{LXC.}
    \cite{celesti2016exploring} indica que LXC (Linux Containers) son  similares a Máquinas Virtuales
    en el hecho de que ambos poseen un Sistema Operativo completamente funcional.
    Los LXC son agnósticos con respecto al sistema de archivos y por defecto almacenan data con estado.
\end{enumerate}
\vspace{-1em}


% \subsubsection{\textit{Orquestración de Contenedores}}
%
% - Kubernetes
% - Docker Swarm
%
%
% \subsubsection{\textit{Herramientas de CI/CD}}
%  
% \begin{itemize}
%   \item \textbf{Gitlab CI}
%   \item \textbf{Jenkins}
%   \item \textbf{Gihub Actions}
%   \item \textbf{Travis CI}
% \end{itemize}
